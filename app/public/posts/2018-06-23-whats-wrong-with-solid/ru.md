# SOLID - когда мы свернули не в ту сторону? 

> Годами знание принципов SOLID было стандартом при найме. От кандидатов ожидалось уверенное владение этими принципами. Однако позже один из наших менеджеров, который уже почти не пишет код, усомнился, разумно ли это. Он утверждал, что принцип открытости-закрытости стал менее важен, так как по большей части мы уже не пишем код для крупных монолитов. А вносить изменения в компактные микросервисы - безопасно и просто.
>
> Принцип подстановки Лисков давно устарел, потому что мы уже не уделяем столько внимания наследованию, сколько уделяли 20 лет назад. Думаю, нам стоит рассмотреть позицию Дена Норса о SOLID - “Пишите простой код”
>
> <cite>- Uncle Bob</cite>

Когда вы в последний раз сталкивались с SOLID за пределами собеседований? Буду честен, единственное, что связывает меня с этим набором принципов - это вялые споры за ограничение зон ответственности каких-нибудь сильно разжиревших от наплыва бизнесовой логики компонентов. Ну и конечно же редкие холивары с коллегами и друзьями в рабочих и личных чатах.

Размеренное субботнее утро. Шкворчит на жаровне свежий говяжий отруб. На солнце искрятся два свежих шипящих бокала джин-тоника, а мой добрый друг Василий убеждает меня в том, что ActiveRecord это антипаттерн, потому что сочетает в себе одновременно зоны ответственности репозитория, валидатора и бизнес-логику модели.
Спорить с этим конечно же глупо, факт есть фактом (как и то, что я не встречал проектов на фреймворках, где ActiveRecord является обыденной нормой, без, собственно, этого ActiveRecord'а использования)... однако, я всё таки попробую.

Раз уж дело зашло с джин-тоника, попробуем разобрать и возможно даже переосмыслить их начав, как это ни удивительно, с первой буквы.

## **S** - Single responsibility
Не буду цитировать википедию - описанное там определение знает любой, кто хоть раз ходил на собеседование разработчиком любого уровня, начиная с джуна. Однако, давайте зададимся вопросом - о каких причинах изменения идет там речь? Давайте на примере ActiveRecord и модели, пусть будет **Customer**, пофантазируем, какие причины могут у нас быть для изменения такой модели данных:
1. изменение слоя хранения (господь дал нам postgres и мы переезжаем с языческого mysql)
2. изменение бизнес логики модели (господь забрал у нас емейлы и дал нам номера телефонов)
3. изменение изменение логики валидации (обычно является следствием 1 или 2 пункта, в качестве самостоятельной цели встречается обычно только в виде багфикса, поэтому выделять ее как отдельную причину изменения смысла нет)

Является ли первый пункт действительно серьезной причиной изменения модели? Отвечу - нет. Большинство реализаций ActiveRecord'а так или иначе отделяют слой общения с конечной системой хранения - либо на уровне родительского класса реализующего интерфейс, либо на уровне композиции так же через интерфейс. Поэтому обычно такие задачи решаются минимальными изменениями по типу смены схемы наследования или композиции другого провайдера БД. 
Не стал бы говорить, если б сам не перевозил целый проект на Yii2 с MariaDB на MongoDB. Т.е. даже смена реляционной на документоориентированную БД прошла реально с минимальными доработками. 

Теперь же поговорим об изменениях бизнес логики. И вот тут решение само по себе дает нам прекрасные ограничения в виде того, что AR - имеет одно и только одно представление в БД. Это наше любимое Entity, воспетый краеугольный камень DDD, который инкапсулирует в себе **всю** бизнес логику, связанную с этой сущностью. 

Так причем тут single responsibility, спросите вы? Совсем ополоумел дед со своим джин-тоником?
А смысл в общем-то в том, что в контексте этого принципа в первую очередь стоит думать о причинах изменения именно бизнес логики. 
За полвека ООП мы прекрасно научились тому, что не нужно мешать мухи с котлетами и рассматривать технические причины изменения компонента как отдельные причины изменения в 99% случаев не нужно. Современный программист с молоком первого тимлида впитал необходимость разделения таких вещей, а вот лепить в одном месте бизнес логику из разных контекстов или, прости господи, доменов - еще нет.
Резюмируя по первому пункту скажу, что нынче стоит дополнить и всерьез воспринимать этот принцип как: "должна существовать единственная причина изменения бизнес логики сущности". Поэтому я на абсолютно серьёзных щщах считаю AR соответствующей этому принципу.

## **O** - Open-Closed principle
Проведя за все годы с полтысячи собеседований, я не могу припомнить ни одного испытуемого, который бы внятно раскрыл этот прицип. Более того, на всех (!!!) собеседованях, которые проходил я, наниматели также не понимали о чем они спращивают. Кроме шуток, я проверял это, сознательно лепя шаблонную чушь из википедии что, "код должен быть открыт для расширения, но закрыт для модификации", после чего коллега с пустым взглядом и умным видом кивал мне, мол, молодец - погнали дальше.

Если не читали статью Дяди Боба из далекого 1996-го года ([The Open-Closed Principle](https://web.archive.org/web/20060822033314/http://www.objectmentor.com/resources/articles/ocp.pdf)), попробуйте сами призадуматься, а что это вообще может значить физически? Вот есть код, классы в нём, объекты какие-то. А что делать-то, чтоб закрытым он стал? Решительно непонятно.

А суть то на самом деле проста - Роберт Мартин всего лишь говорит нам всем:
> Эй, пёс, используй абстракции!
>
> <cite>- мог бы быть Uncle Bob</cite>

Этот принцип решает одну простую проблему - когда мы меняем что-то в одном из компонентов, очень плохо, если это приводит по цепочке к сквозному изменению других компонентов, которые по какому-то недоразумению с ним связались.
Как этого избежать? Конечно же завязываться через абстракции. Сам Дядя Боб писал про абстрактные классы, но мы то все сейчас стали больно умные и считаем, что наследование - это фу, а на нашей айти делянке рулит композиция, поэтому - связывайте компоненты через описанные контракты (интерфейсы), обусловленные заранее продуманными юзкейсами, шанс на изменение которых сильно ниже, чем изменение внутри какой-то имплементации.

Что отсюда еще следует? Если мы используем интерфейсы, то значит "Tell, don't ask", а это ведет к инкапсуляции всей логики внутрь сущностей.
Вот так вот этот страшный и очень непонятный принцип свёлся к совокупности чего-то тёплого, близкого и родного.

## **L** - Liskov Substitution principle
Вы же знали, что Лисков - это женщина? Уверен, что это главное что знают люди об этом принципе и частно стремятся блестнуть эти знанием (прям как я сейчас).

А вы знали, что Барбара Лисков никогда не писала про наследование в привычном нам виде? И говорила про классы только в контексте Smalltalk'а. А вот про что она действительно писала, так это про типы и системы подтипов.
Так а в чем собственно разница, спросите вы? 

А разница вот в чем. Если говорить очень грубо, насколько можно это делать в отношении дам (впрочем есть дамы, кто отнюдь не против такого, а то и кто даже просит легкой грубости) - Лисков говорила про типы и системы подтипов. Что подтипы должны обрабатываться также как и типы, и уж если можешь ты Int32 возвести в квадрат (а то и в куб), то и Uint64 пренепременно можешь тоже. Что если коллекция строк умеет добавлять в себя элемент методом Add, от и коллекция float'ов уметь должна также.
Это уже мы, искушенные наследованием классов услышали госпожу Лисков и поняли ее по своему. Не сказать что принцип не правильный, но услышан был определенно не совсем так, как задумывала автор. Ну а в наш век композиции и в целом утрачивает актуальность.

Возможно однажды, когда настроение будет особенно томное, вы решитесь прильнуть к первоисточнику. 
Оставлю эту ссылку тут - [Data Abstraction and Hierarchy](https://dl.acm.org/doi/pdf/10.1145/62139.62141)

## **I** - Interface segregation principle
И это не про шовинизм и борьбу черных братьев. Много писать тут нечего, да и принцип понятен и прост, ровно как определение интерфейса.

Что есть суть интерфейс? Интерфейс - суть контракт, описанный договор взаимодействия. 
> Можете ли вы представить контракт между извозчиком 18го века и купечишкой средней руки, живущем на окраине Лондона, который дюже желает, чтобы оный извозчик покатал их с супружницей вдоль благоухающей Темзы в день свадьбы (это суть контракта - его цель)? А теперь представьте, что он (купечишка, жалкий и скудоумный) решил дописать к контракт: "Да чтоб к карете прилагалось 12 пудов арбузов - заедем к свояку на Леденгольский рынок, торговать будем". "Позвольте, уважаемый, да вы тронулись умом!" - заметит любой здравомыслящий извозчик, - "Я же не торгаш!". 
> И будет категорически прав. Один контракт - одна цель. Вот будьте и вы как тот извозчик, а не как его недалекий заказчик-купец. 

Справедливости ради, я пытался сообразить какой-либо разумный пример такого сверхъинтерфейса, но не смог, т.к. любая его имплеменация нарушала бы сразу несколько других принципов.

## **D** - Dependency inversion
Тут уже либо пятый джин-тоник показал дно бокала, то ли слова стали подходить к концу, но и правда красноречием тут не поблещешь. Давайте начнем с проблемы, с которой данный принцип предлагает бороться. 
> Допустим вы знатный барин, два десятка крепких крепосных, пашут поле, сеют рожь, всё как полагается. Тут бах - чума, два десятка трупов, и барин без урожая, бойцы голодают.
> Или представим, что вы крепостной у барина - оброк конечно платишь, но от бусурман окаянных защищен, поле пашешь - и сам с голоду не помрешь и хозяина кормишь. Тут бах - чума, барин труп, рать разбежалась, пришли бусурмане и всех на вилы.

Просчитались, но где? А надо было и барину и крепостным завязаться на абстракцию - купить подписку на местный невольничий рынок! Умер барин - нашли нового, крестьяне передохли, так и их новых нашли.
Опять всё сводится к абстракциям. Мы уже поняли.

В контексте DIP принято часто упоминать IoC или вообще ServiceLocator, но надо понимать, что DI контейнеры, как форма IoC - является скорее костылем, когда мы не можем явно указывать зависимости из-за большого числа связей. И хоть и завязаны они на абстракциях, но всегда ведут к увеличению числа неявных связей между компонентами, в чем добра никогда не бывает.

## Заключение
А что же делать? 

Отвечу так: 
* держать в голове определения википедии для джунов
* оставить SOLID в покое, спрашивать его на собеседованиях лишь как долг истории развития ООП 
* помнить, что есть множество других классынх принципов, которые не попали в SOLID только потому, что начинались на другие буквы

Обратите внимания на прекрасные GRASP, YAGNI, DRY, мой любимый [Закон Деметры](https://en.wikipedia.org/wiki/Law_of_Demeter)
